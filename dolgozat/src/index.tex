\documentclass[
    parspace, % Add vertical space between paragraphs
    noindent, % No indentation of first lines in each paragraph
    %nohyp, % No hypenation of words
    %twoside, % Double sided format
    %draft, % Quicker draft compilation without rendering images
    %final, % Set final to hide todos
]{elteiktdk}[2023/10/30]

\usepackage{xcolor}
\newcommand{\guessvalue}{}
%\newcommand{\guessvalue}{\color{red} \textbf{$_{?}$}}

\usepackage{tabularx}
\usepackage{booktabs}
\newcolumntype{Y}{>{\centering\arraybackslash}X}

\usepackage{graphicx}

\usepackage{svg}

\usepackage{todonotes}

\newcommand{\rhpad}{\vspace{0.6\baselineskip}}

% The minted package is also supported for source highlighting
%\usepackage[newfloat]{minted}



\title{TDK-dolgozat címe}
\date{2023}
\author{Horváth Dávid}
\degree{Programtervező Informatikus BSc}
\period{2. évfolyam}

% Superivsor(s)' metadata
\supervisor{Témavezető Tamás}
\affiliation{egyetemi tanársegéd}
\cosupervisor{Témavezető Teréz}
\coaffiliation{egyetemi adjunktus}

\university{Eötvös Loránd Tudományegyetem}
\faculty{Informatikai Kar}
\department{XXXXXXXXXXX Tanszék}
\city{Budapest}
\logo{elte_cimer_szines}

\addbibresource{references.bib}

\begin{document}
\documentlang{hungarian}
%\cleardoublepage


\listoftodos
\cleardoublepage

\makecover
\cleardoublepage

\maketitle

\tableofcontents
\cleardoublepage


\todo[inline, color=blue]{általános célúság, nem csak SQL, hanem egyéb (NoSQL, GraphQL? etc.)}
\todo[inline, color=blue]{deklaratív jelleg, adaptáció különféle tesztekhez}
\todo[inline, color=blue]{értékenként csatolható gyakoriság az eloszláshoz}


\begin{abstract}
Lorem ipsum.
\end{abstract}

\chapter{Motiváció}

\section{Bevezetés}

\todo[inline]{section: Bevezetés}

\begin{itemize}
    \item Relational data as a serverless function
    \item TODO
\end{itemize}

\section{Végtelenített virtuális világok}

\todo[inline]{section: Végtelenített virtuális világok}

\section{A fakerek limitációi}

\todo[inline]{section: A fakerek limitációi}

\section{Néhány visszatérő probléma közös nevezője}

\todo[inline]{section: Néhány visszatérő probléma közös nevezője}

\section{Virtuális mockolás: hézag jelei új termék számára?}

\todo[inline]{section: Virtuális mockolás: hézag jelei új termék számára?}

\chapter{Architektúra}

\section{Felépítés}

\todo[inline]{section: Felépítés}

\begin{figure}
\centering
\includesvg{diagram/simplearch}
\caption{A virtuális adatbázis vázlatos architektúrája}
\label{A virtuális adatbázis vázlatos architektúrája}
\end{figure}

\section{Konfiguráció}

\todo[inline]{section: Konfiguráció}

\section{Kiegészítő eszközök és alkalmazások}

\todo[inline]{section: Kiegészítő eszközök és alkalmazások}

\chapter{A virtuális adattár}

\section{A TreeRandom és kapcsolódó API-k}

\todo[inline]{section: A TreeRandom és kapcsolódó API-k}

\section{A storage API}

\todo[inline]{section: A storage API}

\section{A csak-olvasható alapréteg}

Bármilyen imlementáció legyen is mögötte, a storage API egy relációs adatbázist ír le.
Tehát ahhoz, hogy a virtuális adatok funkcionálisan egy valódi (csak-olvasható) relációs adathalmaz képét adják,
nem kell más, mint hogy konzisztens módon elérhetők legyenek a storage API-n keresztül.
A konzisztencia ez esetben két dolgot jelent:

\begin{enumerate}
  \item Felépíthető egy olyan tényleges immutábilis relációs adatbázis ($M$),
        hogy minden lehetséges relációs lekérdezés esetében, amely a közös schemára ($S$) értelmes,
        a virtuális és a tényleges adatbázis esetében visszaadott eredménytábla megegyezik.
  \item Az $S$ schema teljesíti a virtuális adatbázis felhasználói konfigurációját ($C$),
        valamint az $M$-ben szereplő adatok tulajdonságai illeszkednek a $C$-ben leírt megkötésekre.
\end{enumerate}

A virtuális adatokhoz a legalsó szinten a storage API megfelelő hívásaival férünk hozzá.
Ezek a speciális hívások szűk keresztmetszetet képeznek,
hiszen ezek szimulálják például a közvetlen adatelérést is.
Ha ezen hívások performanciája nagyságrendileg (de legalább aszimptotikusan) összemérhető a tényleges adatbázisokéval,
akkor az erre épülő lekérdezésfuttató és egyéb rétegek már
a tényleges adatbázisoknál megszokott módon és nagyságrendi teljesítménnyel tudnak működni.

A lekérdező műveletek esetében két különösen fontos hozzáférési módot kell kiemelni:

\begin{enumerate}
  \item rekordok véletlen elérése (random access)
  \item adott érték előfordulásainak keresése egy oszlopban (reverse index)
\end{enumerate}

Ha e két hozzáférési mód hatékony, akkor már a lekérdezések jelentős részénél
elérhető a tényleges adatbázisokéval összemérhető performancia.

A storage API-ban úgy definiáltuk a megfelelő interfészt,
hogy a keresésen kívül még néhány további funkciót is támogatnia kelljen,
például a rendezést és a $NULL$ értékek kezelését.
A következőkben leírt értékkiosztási módszerek többéségénél természetes módon következik,
hogy ezeket a további elvárásokat is teljesítik.
Az e szempontból problémás esetekre külön ki fogok térni.

\todo[inline]{A csak-olvasható alapréteg további dolgai}

\section{Megoldások a hatékony értékkiosztásra}

Virtuális adatok alatt elsősorban az egy-egy oszlop alá besorakozó,
közös típussal rendelkező mezőértékeket értem.
Úgy is fogalmazhatunk, hogy az adatokat alapvetően oszlop-orientáltan fogjuk előállítani.
Minden oszlophoz tartozik majd egy virtuális adatlista,
melynek hossza egyenlő az adott oszlopot tartalmazó tábla hosszával,
opcionálisan szerepelhetnek benne $NULL$ értékek,
a többi érték típusának pedig kompatibilisnak kell lennie az oszlophoz megadott típussal.

Bár ez legjobban az oszloponként független adatlistákhoz illeszkedik,
valójában más jellegű értékkiosztási módszer is lehet mögötte,
amennyiben az egy-egy oszlophoz tartozó listanézetek biztosítottak.
Majd a több oszlopot érintő megkötések esetében ez lesz a helyzet.
De lássuk először az egyoszlopos értékkiosztások lehetséges módszereit.

\subsection{Egyoszlopos értékkiosztások}

\subsubsection{Előzetes megfontolások}

\todo[inline, color=red]{subsubsection: Egyoszlopos értékkiosztások / Előzetes megfontolások (fő szempontok: a TreeRandom használata, értékelérés, keresés, rendezés)}

\subsubsection{$NULL$ értékek kezelése}

\todo[inline, color=red]{subsubsection: Egyoszlopos értékkiosztások / $NULL$ értékek kezelése}

\subsubsection{Egyszerű értékkiosztások}

Tényleges adatbázisokban némely esetben meglehetősen következetes módon
szerepelnek az értékek az oszlop értéklistájában.
Természetesen az ilyen esetek szimulálása a legegyszerűbb.

Triviális eset, ha egy oszlop mezői egy közös konstans értéket tartalmaznak.

Ha olyan adathalmazt szimulálunk, melyre megengedhető a feltevés,
hogy sem törlés, sem releváns értelemben problémás felülírás nem történt még,
úgy egyes oszlopok szekvenciális alapon generálhatók.
Az ilyen esetekben az $n$-edik érték lekérése
egy egyszerű lineáris függvénnyel számolható.
Az érték keresése hasonló, lényegileg az inverz függvényt kell alkalmazni.

A szekvenciális oszlopoknál az érték megegyezik a rekord 1-től indított sorszámával.

Időbélyegeket is generálhatunk hasonló módon,
amennyiben megengedhető, hogy a szimulált időadatok között egyenletes időközök legyenek.

\subsubsection{Kétfázisú értékkiosztás}

\todo[inline, color=red]{subsubsection: Kétfázisú értékkiosztás}

\begin{figure}
\centering
\includesvg{diagram/distribution}
\caption{A kétfázisú értékkiosztás alapelve: egymás után végrehajtott visszafejthető disztribúció és permutáció}
\label{A kétfázisú értékkiosztás alapelve}
\end{figure}

\begin{figure}
\centering
\includesvg{diagram/getvalue}
\caption{Adatlekérés a kétfázisú értékkiosztásból}
\label{Adatlekérés a kétfázisú értékkiosztásból}
\end{figure}

\begin{figure}
\centering
\includesvg{diagram/findvalue}
\caption{Keresés a kétfázisú értékkiosztásban: a rendezett értékkészlet és a vetítések megfordíthatósága biztosítja a gyors kereshetőséget az virtuális listában}
\label{Keresés a kétfázisú értékkiosztásban}
\end{figure}

\subsubsection{Kétfázisú értékkiosztás gyakoriságtáblázattal}

\todo[inline, color=red]{subsubsection: Kétfázisú értékkiosztás gyakoriságtáblázattal}

\subsubsection{Zajosan monoton értékkiosztások}

A rányújtásnak az előzőleg monoton függvény előállításához használt elve
másféle értékkiosztáshoz is felhasználható,
nevezetesen olyan (szigorúan vagy nem szigorúan) monoton adatsor előállításához,
melynek egyes értékei összességében egy adott sűrűség szerint növekednek
(vagy csökkennek; az egyszerűség kedvéért most csak a növekedő esetről lesz szó),
de lokálisan nagy az egyenetlenség.
Ezt is két lépésben fogjuk megvalósítani.

Az első lépés alapelve tehát hasonló az előbbi megoldás első fázisához.
Ám itt nem lehetséges értékeket vetítünk ki a tábla hosszára,
hanem a táblahossznyi alaphalmazt vetítjük majd ki egy diszkrét lehetséges értékkészletre.
Minden sorindexhez hozzárendelődik egy (a szigorú monotonitás elvárása esetén nemüres)
dedikált sáv az értékkészletből.

A második lépés választ egy értéket a sávból.
Nem szigoróan monoton értéksor esetén megengedjük az üres sávot is,
és ilyen esetekben mindig a rákövetkező elemet választjuk.\footnote{
  Ebben az esetben explicite ki kell zárni, hogy az utolsó sáv üres legyen.
  Ez legtermészetesebben egy logikai paraméter beiktatásával érthető el,
  amelyet a rekurzió során mindig a csak felsőbb sávra küldünk tovább \texttt{true} értékkel
  (a többire \texttt{false} értékkel),
  alapértelmezett értéke \texttt{true}.
  Ha \texttt{true} értéket kaptunk, biztosítani kell, hogy az aktuális felsőbb sáv ne legyen üres.
}

Az érték elérése ekkor úgy történik, hogy először lekérjük az értéksávot a rányújtó függvénytől,
majd meghívjuk az értékválasztó függvényt,
melynek paraméterei az értéksáv, a sorindex és a \texttt{TreeRandom}-ból vett seed lesznek.
Egy kézenfekvő megvalósítás,
hogy a sorindex és a seed alapján inicializált randomgenerátorral
generáltatunk egy véletlen értéket, ami a sávba esik.

Az értéksávra való keresés úgy történik, hogy a vesszük a minimális és a maximális keresett értéket,
és az inverz rányújtást használva megkeressük a megfelelő sorindexeket, amelyek sávjához az érté tartozik.
Ezen sorindexek feszítik ki majd a találati sorindexsávot.
Hogy az alsó érték beletartozik-e, annak eldöntéséhez le kell generálni
az alső sorindexhez a konkrét értéket, és ellenőrizni, hogy nagyobbegyenlő-e,
mint a keresett alsó érték.
A felső érték esetében hasonlóan kell eljárni.

A rendezés triviális, mivel az értékek eleve rendezettek.

Ezzel az eljárással nem csak zajossá tudtuk tenni az eloszlást,
de a monotonitás garantálása mellett megengedtük,
hogy az értékek esetlegesen csomósodhassanak,
illetve elméletben tetszőlegesen eltávolodhassanak attól a helytől,
amit egy egyszerű, szigorúan egyenletes kiosztás esetén vettek volna föl.

Ez az értékkiosztás különösen alkalmas időbélyegek szimulálására,
amikor az események általános sűrűsége adott,
de véletlenszerű, zajos kiemenetet szeretnénk látni.

\subsubsection{Értékkiosztás reguláris kifejezés alapján}

Ha elengedjük a gyors keresés kritériumát,
akkor a reguláris kifejezés alapján történő értékkiosztást nagyon könnyen megvalósíthatjuk
egy véges automatával történő véletlenszerű inverz mintaillesztéssel\footnote{
  A jelenlegi implementáció a \textit{generex} könyvtárat használja erre.
},
(a sorindex és a \texttt{TreeRandom}-ból vett seed figyelembevételével).

Ha azonban fenn szeretnénk tartani a gyors keresés lehetőségét,
szükséges lesz, hogy képezni tudjuk az adott reguláris kifejezésre illeszkedő összes string virtuális listáját.
Azaz bármely $n$ sorindexre elő kell tudnunk állítani az $n$-edik illeszkedő stringet
(méghozzá abc-rendben, nem pedig a reguláris kifejezés szerkezete alapján).
És fordítva, tetszőleges stringre meg kell tudni mondani,
hányadik illeszkedő stringgel azonos vagy melyikhez van közel, ha nem illeszkedik.
Ha már van egy ilyen virtuális listánk, azt a kétfázisú értékkiosztással könnyen a kívánt oszloppá alakíthatjuk.

A megoldás a reguláris kifejezések lehetőségeinek csak valamilyen (erősen limitált) részhalmazát fogja támogatna.
De még így is bőven lefedi az olyan egyszerű eseteket, mint például a telefonszámok, email-címek stb.

Az ilyen típusú szöveggenerálás részletes bemutatása kimutat a jelen dolgozat keretei közül,
így ennek ismertetését itt mellőzöm\footnote{
  Egy egyszerű erre készült prototípus a \texttt{strex} könyvtár.
}.

\subsubsection{Full-text indexelt értékkiosztás}

A full-text indexelés legegyszerűbb formáját fogjuk támogatni:
tudunk majd keresni a szövegben előforduló szavakra,
azaz vissza tudjuk adni azon sorindexeket,
amelyekhez tartozó szövegekben szerepel a keresett szó.

Most egy kicsit egyszerűsített modellt mutatok be,
melyben a szavak betűkarakterek sorozatai,
és ezeket szóközök választják el.
Az egyéb szövegjellemzők (például központozás) hozzáadása nehézség nélkül kivitelezhető,
az áttekinthetőség kedvéért ezekkel most nem foglalkozom.

A módszert két generálási szakaszra bontjuk, a prefix és a fennamaradó rész generálására.

Kezdjük a prefix kiosztásával.
Legyen a szavak minimális száma $L$ ($L > 0$).
Vegyük $L$ darab szólistát, melyek rendre az $n$-edik szó lehetséges értékeit tartalmazzák.\footnote{
  Legegyszerűbb esetben ezek azonosak, és egy szótár szavai vagy generált értékek.
  De egy szofisztikáltabb változatban figyelembe vehetjük a valós szövegek jellemzőit.
}
Vegyük most azt a virtuális listát, melyen keresztül ezek Descartes-szorzatát érjük el.
Nem kell mást tennünk, mint ezt a listát a kétfázisú értékkiosztással alkalmazni.
Ha jó nekünk, hogy minden érték $L$ szóból áll, készen is vagyunk.

Ha viszont változó szószámot szeretnénk,
akkor még gondoskodni kell a szövegek fennmaradó részének előállításáról.
Ehhez állítsunk elő egy-egy függvényt a szótár minden egyes szavára\footnote{
  Feltételezzük, hogy a szótár nem túl nagy (például lorem ipsum szavak).
  De nagy szótár esetén is van egy egyszerű kerülőmegoldás:
  a függvényt több szinten valósítjuk meg,
  először a szótár nagy szeleteit osztjuk ki,
  majd azon belül kisebb szeleteket, és így tovább, végül az egyes szavakat.
  Így a szó ellenőrzése az adott sorindexre még mindig logaritmikus számítási igényű.
}, mely lényegileg a két logikai érték rányújtása:
bármely sorindexre megadja, hogy az adott szó szerepel-e a hozzá tartozó szövegben,
illetve bármely szóra megadja a sorindexeket, ahol a szó szerepel.

Már csak annyi feladatunk van, hogy bármely sorindexre következetesen visszaadjunk egy olyan szöveget,
mely megfelel ennek a két kritériumnak:

\begin{enumerate}
  \item Az első $L$ szó egyezik az első szakaszban meghatározott prefixszel.
  \item A fennmaradó rész pontosan azokat a szavakat tartalmazza,
        amely a fennmaradó rész kiosztásánál leírt szóválasztásnak megfelel.
        Ugyanaz a szó többször is szerepelhet.
\end{enumerate}

A második kritérium természetesen legegyszerűbben úgy teljesíthető,
hogy a kiválasztott szavakat abc-rendben felsoroljuk.
De mivel teljes szabadságunk van (az index már biztosított),
tetszőlegesen szofisztikált módszereket alkalmazhatunk a minél életszerűbb szöveg kialakítására
(ez egy skálázható opció).

A rendezésnél kihasználjuk, hogy az első $L$ szóra már van egy hagyományos indexünk,
így a prefixek egymáshoz képesti rendezése már megoldott.
Mivel a Descartes-szorzat miatt a lehetséges prefixek listája igen nagy,
feltehetjük, hogy jellemzően nem nagyon lesznek ismétlődő prefixek,
de ha igen, csak azokon belül kell tényleges összehasonlításos rendezést végezni.

\subsubsection{Értékkiosztás oszlopok közötti megkötésekkel}

\todo[inline]{subsubsection: Értékkiosztás oszlopok közötti megkötésekkel}

\subsubsection{Egyéb számított értékek}

\todo[inline]{subsubsection: Egyéb számított értékek}






\section{Az írhatósági réteg}

\todo[inline]{section: Az írhatósági réteg}

\section{Továbbfejlesztési tervek}

\todo[inline]{section: Továbbfejlesztési tervek}

\subsection{Megkötések oszlopok között}

\todo[inline]{subsection: Megkötések oszlopok között}

\chapter{Lekérdezések futtatása}

\section{A beépített SQL-futtató}

\todo[inline]{section: A beépített SQL-futtató}

\section{Használat az Apache Calcite keretrendszerrel}

\todo[inline]{section: Használat az Apache Calcite keretrendszerrel}

\section{Munkamenetek}

\todo[inline]{section: Munkamenetek}

\chapter{Kiegészítő eszközök és alkalmazások}

\section{Hálózati protokollok}

\todo[inline]{section: Hálózati protokollok}

\section{JDBC}

\todo[inline, color=red]{section: JDBC}

\section{REPL}

\todo[inline]{section: REPL}

\todo[inline]{További kiegészítő eszközök?}

\chapter{Összehasonlítás az elterjedt tipikus megoldásokkal}

\section{Megközelítések}

\todo[inline]{section: Megközelítések}

\section{A jelen megoldás sajátos fókuszai}

\todo[inline]{section: A jelen megoldás sajátos fókuszai}

\section{Empirikus tesztek}

\todo[inline]{section: Empirikus tesztek}

\begin{table}
\settowidth\rotheadsize{mmmmmmm}
\begin{tabularx}{\textwidth}{l| c *{8}{|Y} c}
  \toprule
  \parbox{2cm}{Fázis / \\ aspektus} &
    \rothead{MySQL \\ (fájlmásolással)} &
    \rothead{MySQL \\ (SQL dumppal)} &
    \rothead{MySQL + anon. \\ (fájlmásolással)} &
    \rothead{MySQL + anon. \\ (SQL dumppal)} &
    \rothead{MySQL + faker} &
    \rothead{H2 + faker \\ (embedded)} &
    \rothead{H2 Views \\ (embedded)} &
    \rothead{HoloDB \\ (default exec.)} &
    \rothead{HoloDB \\ (Calcite exec.)} 
    \\
  \midrule
  \parbox{2cm}{\rhpad Projekt \\ előfeltétele \rhpad} &
    \multicolumn{2}{c|}{ \begin{tabular}{@{}c@{}}létező \\ adatbázis\end{tabular} } & % MySQL
    \multicolumn{2}{c|}{ \begin{tabular}{@{}c@{}}kész \\ schema\end{tabular} } & % MySQL + anon.
    \multicolumn{5}{c|}{ \begin{tabular}{@{}c@{}}vázlatos \\ schema\end{tabular} } \\ % MySQL + anon.
  \parbox{2cm}{\rhpad Mockolás \\ előfeltétele \rhpad} &
    \multicolumn{2}{c|}{ \begin{tabular}{@{}c@{}}létező \\ adatbázis\end{tabular} } & % MySQL
    \multicolumn{2}{c|}{ \begin{tabular}{@{}c@{}}kész \\ schema\end{tabular} } & % MySQL + anon.
    \multicolumn{3}{c|}{ \begin{tabular}{@{}c@{}}vázlatos \\ schema\end{tabular} } & % MySQL + anon.
    \multicolumn{2}{c}{ \begin{tabular}{@{}c@{}}deklaratív \\ konfiguráció\end{tabular} } \\ % HoloDB
  \parbox{2cm}{\rhpad Data dump \\ (seconds) \rhpad} &
    0.05\guessvalue & % MySQL \\ (fájlmásolással)
    0.94\guessvalue & % MySQL \\ (SQL dumppal)
    0.32\guessvalue & % MySQL + anon. \\ (fájlmásolással)
    1.23\guessvalue & % MySQL + anon. \\ (SQL dumppal)
    0.12\guessvalue & % MySQL + faker
    0.11\guessvalue & % H2 + faker \\ (embedded)
    0 & % H2 Views \\ (embedded)
    0 & % HoloDB \\ (default exec.)
    0 \\ % HoloDB \\ (Calcite exec.)
  \parbox{2cm}{\rhpad Klónozás \\ tesztenként \\ (seconds) \rhpad} &
    \multicolumn{5}{c|}{ \begin{tabular}{@{}c@{}}0.05\guessvalue\end{tabular} } & % MySQL
    0.11\guessvalue & % H2 + faker \\ (embedded)
    0 & % H2 Views \\ (embedded)
    0 & % HoloDB \\ (default exec.)
    0 \\ % HoloDB \\ (Calcite exec.)
  \parbox{2cm}{\rhpad Alap \\ tesztszvit \\ (seconds) \rhpad} &
    \multicolumn{5}{c|}{ \begin{tabular}{@{}c@{}}0.02\guessvalue\end{tabular} } & % MySQL
    0.03\guessvalue & % H2 + faker \\ (embedded)
    0.68\guessvalue & % H2 Views \\ (embedded)
    0.11\guessvalue & % HoloDB \\ (default exec.)
    0.23\guessvalue \\ % HoloDB \\ (Calcite exec.)
  \parbox{2cm}{\rhpad Haladó \\ tesztszvit \\ (seconds) \rhpad} &
    \multicolumn{5}{c|}{ \begin{tabular}{@{}c@{}}1.72\guessvalue\end{tabular} } & % MySQL
    0.96\guessvalue & % H2 + faker \\ (embedded)
    12.7\guessvalue & % H2 Views \\ (embedded)
    3.1\guessvalue & % HoloDB \\ (default exec.)
    3.5\guessvalue \\ % HoloDB \\ (Calcite exec.)
  \parbox{2cm}{\rhpad Tear down \\ (seconds) \rhpad} &
    0.05\guessvalue & % MySQL \\ (fájlmásolással)
    0.94\guessvalue & % MySQL \\ (SQL dumppal)
    0.32\guessvalue & % MySQL + anon. \\ (fájlmásolással)
    1.23\guessvalue & % MySQL + anon. \\ (SQL dumppal)
    0.12\guessvalue & % MySQL + faker
    0.05\guessvalue & % H2 + faker \\ (embedded)
    0.05\guessvalue & % H2 Views \\ (embedded)
    0.01\guessvalue & % HoloDB \\ (default exec.)
    0.01\guessvalue \\ % HoloDB \\ (Calcite exec.)
  \parbox{2cm}{\rhpad Össztárhely \\ (bytes) \rhpad} &
    370M\guessvalue & % MySQL \\ (fájlmásolással)
    510M\guessvalue & % MySQL \\ (SQL dumppal)
    380M\guessvalue & % MySQL + anon. \\ (fájlmásolással)
    520M\guessvalue & % MySQL + anon. \\ (SQL dumppal)
    350M\guessvalue & % MySQL + faker
    360M\guessvalue & % H2 + faker \\ (embedded)
    1M\guessvalue & % H2 Views \\ (embedded)
    1M\guessvalue & % HoloDB \\ (default exec.)
    1M\guessvalue \\ % HoloDB \\ (Calcite exec.)
    
    
  \bottomrule
\end{tabularx}
\caption{Az \texttt{imdb\_ijs} dataset mockolásának performanciája a vizsgált megközelítésekkel, azonos tesztforgatókönyv mellett}
\label{tab:comp_table}
\end{table}


\chapter{Konklúzió}

\todo[inline]{section: Konklúzió}

\end{document}