\documentclass[
    parspace, % Add vertical space between paragraphs
    noindent, % No indentation of first lines in each paragraph
    %nohyp, % No hypenation of words
    %twoside, % Double sided format
    %draft, % Quicker draft compilation without rendering images
    %final, % Set final to hide todos
]{elteiktdk}[2023/10/30]

\usepackage{xcolor}
\newcommand{\guessvalue}{}
%\newcommand{\guessvalue}{\color{red} \textbf{$_{?}$}}

\usepackage{tabularx}
\usepackage{booktabs}
\newcolumntype{Y}{>{\centering\arraybackslash}X}

\usepackage{graphicx}
\usepackage{svg}
\usepackage{todonotes}
\usepackage{float}

\newcommand{\rhpad}{\vspace{0.6\baselineskip}}

% The minted package is also supported for source highlighting
%\usepackage[newfloat]{minted}



\title{TDK-dolgozat címe}
\date{2023}
\author{Horváth Dávid}
\degree{Programtervező Informatikus BSc}
\period{2. évfolyam}

% Superivsor(s)' metadata
\supervisor{Témavezető Tamás}
\affiliation{egyetemi tanársegéd}
\cosupervisor{Témavezető Teréz}
\coaffiliation{egyetemi adjunktus}

\university{Eötvös Loránd Tudományegyetem}
\faculty{Informatikai Kar}
\department{XXXXXXXXXXX Tanszék}
\city{Budapest}
\logo{elte_cimer_szines}


\addbibresource{references.bib}

\begin{document}
\documentlang{hungarian}
%\cleardoublepage


\listoftodos
\cleardoublepage

\makecover
\cleardoublepage

\maketitle

\tableofcontents
\cleardoublepage


\todo[inline, color=blue]{általános célúság, nem csak SQL, hanem egyéb (NoSQL, GraphQL? etc.)}
\todo[inline, color=blue]{deklaratív jelleg, adaptáció különféle tesztekhez}
\todo[inline, color=blue]{értékenként csatolható gyakoriság az eloszláshoz}


\begin{abstract}
Lorem ipsum.
\end{abstract}

\chapter{Motiváció}

\section{Bevezetés}

\todo[inline]{section: Bevezetés}

\begin{itemize}
    \item Relational data as a serverless function
    \item TODO
\end{itemize}

\section{Végtelenített virtuális világok}

\todo[inline]{section: Végtelenített virtuális világok}

\section{A fakerek limitációi}

\todo[inline]{section: A fakerek limitációi}

\section{Néhány visszatérő probléma közös nevezője}

\todo[inline]{section: Néhány visszatérő probléma közös nevezője}

\section{Virtuális mockolás: hézag jelei új termék számára?}

\todo[inline]{section: Virtuális mockolás: hézag jelei új termék számára?}

\chapter{Architektúra}

\section{Felépítés}

\todo[inline]{section: Felépítés}

\begin{figure}[H]
\centering
\includesvg{diagram/simplearch}
\caption{A virtuális adatbázis vázlatos architektúrája}
\label{A virtuális adatbázis vázlatos architektúrája}
\end{figure}

\section{Konfiguráció}

\todo[inline]{section: Konfiguráció}

\section{Kiegészítő eszközök és alkalmazások}

\todo[inline]{section: Kiegészítő eszközök és alkalmazások}

\chapter{A virtuális adattár}

\section{A TreeRandom és kapcsolódó API-k}

\todo[inline]{section: A TreeRandom és kapcsolódó API-k}

\section{A storage API}

\todo[inline]{section: A storage API}

\section{A csak-olvasható alapréteg}

Bármilyen imlementáció legyen is mögötte, a storage API egy relációs adatbázist ír le.
Tehát ahhoz, hogy a virtuális adatok funkcionálisan egy valódi (csak-olvasható) relációs adathalmaz képét adják,
nem kell más, mint hogy konzisztens módon elérhetők legyenek a storage API-n keresztül.
A konzisztencia ez esetben két dolgot jelent:

\begin{enumerate}
  \item Felépíthető egy olyan tényleges immutábilis relációs adatbázis ($M$),
        hogy minden lehetséges relációs lekérdezés esetében, amely a közös schemára ($S$) értelmes,
        a virtuális és a tényleges adatbázis esetében visszaadott eredménytábla megegyezik.
  \item Az $S$ schema teljesíti a virtuális adatbázis felhasználói konfigurációját ($C$),
        valamint az $M$-ben szereplő adatok tulajdonságai illeszkednek a $C$-ben leírt megkötésekre.
\end{enumerate}

A virtuális adatokhoz a legalsó szinten a storage API megfelelő hívásaival férünk hozzá.
Ezek a speciális hívások szűk keresztmetszetet képeznek,
hiszen ezek szimulálják például a közvetlen adatelérést is.
Ha ezen hívások performanciája nagyságrendileg (de legalább aszimptotikusan) összemérhető a tényleges adatbázisokéval,
akkor az erre épülő lekérdezésfuttató és egyéb rétegek már
a tényleges adatbázisoknál megszokott módon és nagyságrendi teljesítménnyel tudnak működni.

A lekérdező műveletek esetében két különösen fontos hozzáférési módot kell kiemelni:

\begin{enumerate}
  \item rekordok véletlen elérése (random access)
  \item adott érték előfordulásainak keresése egy oszlopban (reverse index)
\end{enumerate}

Ha e két hozzáférési mód hatékony, akkor már a lekérdezések jelentős részénél
elérhető a tényleges adatbázisokéval összemérhető performancia.

A storage API-ban úgy definiáltuk a megfelelő interfészt,
hogy a keresésen kívül még néhány további funkciót is támogatnia kelljen,
például a rendezést és a $NULL$ értékek kezelését.
A következőkben leírt értékkiosztási módszerek többéségénél természetes módon következik,
hogy ezeket a további elvárásokat is teljesítik.
Az e szempontból problémás esetekre külön ki fogok térni.

\todo[inline]{További megjegyzések a csak-olvasható alapréteghez}

\section{Megoldások a hatékony értékkiosztásra}

Virtuális adatok alatt elsősorban az egy-egy oszlop alá besorakozó,
közös típussal rendelkező mezőértékeket értem.
Úgy is fogalmazhatunk, hogy az adatokat alapvetően oszlop-orientáltan fogjuk előállítani.
Minden oszlophoz tartozik majd egy virtuális adatlista,
melynek hossza egyenlő az adott oszlopot tartalmazó tábla hosszával,
opcionálisan szerepelhetnek benne $NULL$ értékek,
a többi érték típusának pedig kompatibilisnak kell lennie az oszlophoz megadott típussal.

Bár ez legjobban az oszloponként független adatlistákhoz illeszkedik,
valójában más jellegű értékkiosztási módszer is lehet mögötte,
amennyiben az egy-egy oszlophoz tartozó listanézetek biztosítottak.
Majd a több oszlopot érintő megkötések esetében ez lesz a helyzet.
De lássuk először az egyoszlopos értékkiosztások lehetséges módszereit.

\subsection{Indexelt egyoszlopos értékkiosztások}

\subsubsection{Előzetes megfontolások}

E következőkben olyan értékkiosztási módszereket veszek végig,
amelyek lehetőleg biztosítják az alábbiakat:

\begin{enumerate}
  \item hatékony elérés (random access)
  \item pozíciótól függő érték (seed + sorindex)
  \item hatékony kereshetőség valamilyen formában
  \item hatékony rendezés
\end{enumerate}

Az egyes esetekben megvizsgálom majd, hogyan teljesíthetők ezek az elvárások.

\subsubsection{$NULL$ értékek kezelése}

Általánosan, bBármely értékkiosztási módszerhez könnyen hozzáilleszthető a $NULL$ értékek támogatása.
Mindössze az szükséges, hogy az értékkiosztást a tábla méreténél kisebb intervallumra végezzük,
a maradék helyeket pedig $NULL$-nak tekintjük.
Ezen felül opcionálisan egy permutáció beiktatásával az értékeket elkeverhetjük,
ami által a $NULL$ értékek is szétszórtan szerepelnek majd.

Nem szükséges ez a plusz kompozíció,
ha a fentiek magába az eredeti értékkiosztásba is könnyen beépíthetők.
Például a kétfázisú értékkiosztásokba egyszerűen felvehető a $NULL$ mint érték.

Akár beépítetten, akár plusz kompozícióval van megvalósítva a $NULL$ értékek kezelése,
természetesen figyelni kell a speciális kezelésre a keresés-rendezés során.

A fentiek fényében az egyes értékkiosztások tárgyalásánál a $NULL$ értékek kezelésével nem foglalkozom.

\subsubsection{Egyszerű értékkiosztások}

Tényleges adatbázisokban némely esetben meglehetősen következetes módon
szerepelnek az értékek az oszlop értéklistájában.
Természetesen az ilyen esetek szimulálása a legegyszerűbb.

Triviális eset, ha egy oszlop mezői egy közös konstans értéket tartalmaznak.

Ha olyan adathalmazt szimulálunk, melyre megengedhető a feltevés,
hogy sem törlés, sem releváns értelemben problémás felülírás nem történt még,
úgy egyes oszlopok szekvenciális alapon generálhatók.
Az ilyen esetekben az $n$-edik érték lekérése
egy egyszerű lineáris függvénnyel számolható.
Az érték keresése hasonló, lényegileg az inverz függvényt kell alkalmazni.

A szekvenciális oszlopoknál az érték megegyezik a rekord 1-től indított sorszámával.

Időbélyegeket is generálhatunk hasonló módon,
amennyiben megengedhető, hogy a szimulált időadatok között egyenletes időközök legyenek.

\subsubsection{Kétfázisú értékkiosztás}

\todo[inline, color=red]{subsubsection: Kétfázisú értékkiosztás (bevezetés, leírás)}

Talán a leggyakoribb eset, hogy előre ismert véges értékkészlet elemeeit szeretnénk viszontlátni az oszlopban,
mégpedig összevissza

\begin{figure}[H]
\centering
\includesvg{diagram/distribution}
\caption{A kétfázisú értékkiosztás alapelve: egymás után végrehajtott visszafejthető disztribúció és permutáció}
\label{A kétfázisú értékkiosztás alapelve}
\end{figure}

\begin{figure}[H]
\centering
\includesvg{diagram/getvalue}
\caption{Adatlekérés a kétfázisú értékkiosztásból}
\label{Adatlekérés a kétfázisú értékkiosztásból}
\end{figure}

\begin{figure}[H]
\centering
\includesvg{diagram/findvalue}
\caption{Keresés a kétfázisú értékkiosztásban: a rendezett értékkészlet és a vetítések megfordíthatósága biztosítja a gyors kereshetőséget az virtuális listában}
\label{Keresés a kétfázisú értékkiosztásban}
\end{figure}

Egy adott érték lekérése egyszerűen így történik:

\begin{verbatim}
def getValueOfMonotonic(i, start, end):
    flip = split(start, end)
    if i < flip:
        return getValueOfMonotonic(i, start, flip)
    else:
        return getValueOfMonotonic(i, flip, end)
\end{verbatim}

\todo[inline, color=red]{Nyújtás: index-pszeudokód + leírás}

\subsubsection{Kétfázisú értékkiosztás gyakoriságtáblázattal}

\todo[inline, color=red]{subsubsection: Kétfázisú értékkiosztás gyakoriságtáblázattal}

\subsubsection{Zajosan monoton értékkiosztások}

A rányújtásnak az előzőleg monoton függvény előállításához használt elve
másféle értékkiosztáshoz is felhasználható,
nevezetesen olyan (szigorúan vagy nem szigorúan) monoton adatsor előállításához,
melynek egyes értékei összességében egy adott sűrűség szerint növekednek
(vagy csökkennek; az egyszerűség kedvéért most csak a növekedő esetről lesz szó),
de lokálisan nagy az egyenetlenség.
Ezt is két lépésben fogjuk megvalósítani.\footnote{
  A két lépés általánosítható egy általános sűrűségfüggvény és egy zajfüggvény komponációjává,
  ahol a sűrűségfüggvény meredeksége és a zajfüggvény kilengése közötti viszonyt kell biztosítani
  (hogy az értékek ne ugorják át egymást).
  Itt most nem foglalkozunk ezzel az általánosabb kerettel.
}

Az első lépés alapelve tehát hasonló az előbbi megoldás első fázisához.
Ám itt nem lehetséges értékeket vetítünk ki a tábla hosszára,
hanem a táblahossznyi alaphalmazt vetítjük majd ki egy diszkrét lehetséges értékkészletre.
Minden sorindexhez hozzárendelődik egy (a szigorú monotonitás elvárása esetén nemüres)
dedikált sáv az értékkészletből.

A második lépés választ egy értéket a sávból.
Nem szigoróan monoton értéksor esetén megengedjük az üres sávot is,
és ilyen esetekben mindig a rákövetkező elemet választjuk.\footnote{
  Ebben az esetben explicite ki kell zárni, hogy az utolsó sáv üres legyen.
  Ez legtermészetesebben egy logikai paraméter beiktatásával érthető el,
  amelyet a rekurzió során mindig a csak felsőbb sávra küldünk tovább \texttt{true} értékkel
  (a többire \texttt{false} értékkel),
  alapértelmezett értéke \texttt{true}.
  Ha \texttt{true} értéket kaptunk, biztosítani kell, hogy az aktuális felsőbb sáv ne legyen üres.
}

Az érték elérése ekkor úgy történik, hogy először lekérjük az értéksávot a rányújtó függvénytől,
majd meghívjuk az értékválasztó függvényt,
melynek paraméterei az értéksáv, a sorindex és a \texttt{TreeRandom}-ból vett seed lesznek.
Egy kézenfekvő megvalósítás,
hogy a sorindex és a seed alapján inicializált randomgenerátorral
generáltatunk egy véletlen értéket, ami a sávba esik.

Az értéksávra való keresés úgy történik, hogy a vesszük a minimális és a maximális keresett értéket,
és az inverz rányújtást használva megkeressük a megfelelő sorindexeket, amelyek sávjához az érté tartozik.
Ezen sorindexek feszítik ki majd a találati sorindexsávot.
Hogy az alsó érték beletartozik-e, annak eldöntéséhez le kell generálni
az alső sorindexhez a konkrét értéket, és ellenőrizni, hogy nagyobbegyenlő-e,
mint a keresett alsó érték.
A felső érték esetében hasonlóan kell eljárni.

A rendezés triviális, mivel az értékek eleve rendezettek.

Ezzel az eljárással nem csak zajossá tudtuk tenni az eloszlást,
de a monotonitás garantálása mellett megengedtük,
hogy az értékek esetlegesen csomósodhassanak,
illetve elméletben tetszőlegesen eltávolodhassanak attól a helytől,
amit egy egyszerű, szigorúan egyenletes kiosztás esetén vettek volna föl.

Ez az értékkiosztás különösen alkalmas időbélyegek szimulálására,
amikor az események általános sűrűsége adott,
de véletlenszerű, zajos kiemenetet szeretnénk látni.

\subsubsection{Összetett értékek kezelése}

\subsubsection{Értékkiosztás reguláris kifejezés alapján}

Ha elengedjük a gyors keresés kritériumát,
akkor a reguláris kifejezés alapján történő értékkiosztást nagyon könnyen megvalósíthatjuk
egy véges automatával történő véletlenszerű inverz mintaillesztéssel\footnote{
  A jelenlegi implementáció a \textit{generex} könyvtárat használja erre.
},
(a sorindex és a \texttt{TreeRandom}-ból vett seed figyelembevételével).

Ha azonban fenn szeretnénk tartani a gyors keresés lehetőségét,
szükséges lesz, hogy képezni tudjuk az adott reguláris kifejezésre illeszkedő összes string virtuális listáját.
Azaz bármely $n$ sorindexre elő kell tudnunk állítani az $n$-edik illeszkedő stringet
(méghozzá abc-rendben, nem pedig a reguláris kifejezés szerkezete alapján).
És fordítva, tetszőleges stringre meg kell tudni mondani,
hányadik illeszkedő stringgel azonos vagy melyikhez van közel, ha nem illeszkedik.
Ha már van egy ilyen virtuális listánk, azt a kétfázisú értékkiosztással könnyen a kívánt oszloppá alakíthatjuk.

A megoldás a reguláris kifejezések lehetőségeinek csak valamilyen (erősen limitált) részhalmazát fogja támogatna.
De még így is bőven lefedi az olyan egyszerű eseteket, mint például a telefonszámok, email-címek stb.

Az ilyen típusú szöveggenerálás részletes bemutatása kimutat a jelen dolgozat keretei közül,
így ennek ismertetését itt mellőzöm\footnote{
  Egy egyszerű erre készült prototípus a \texttt{strex} könyvtár.
}.

\subsubsection{Full-text indexelt értékkiosztás}

A full-text indexelés legegyszerűbb formáját fogjuk támogatni:
tudunk majd keresni a szövegben előforduló szavakra,
azaz vissza tudjuk adni azon sorindexeket,
amelyekhez tartozó szövegekben szerepel a keresett szó.

Most egy kicsit egyszerűsített modellt mutatok be,
melyben a szavak betűkarakterek sorozatai,
és ezeket szóközök választják el.
Az egyéb szövegjellemzők (például központozás) hozzáadása nehézség nélkül kivitelezhető,
az áttekinthetőség kedvéért ezekkel most nem foglalkozom.

A módszert két generálási szakaszra bontjuk, a prefix és a fennamaradó rész generálására.

Kezdjük a prefix kiosztásával.
Legyen a szavak minimális száma $L$ ($L > 0$).
Vegyük $L$ darab szólistát, melyek rendre az $n$-edik szó lehetséges értékeit tartalmazzák.\footnote{
  Legegyszerűbb esetben ezek azonosak, és egy szótár szavai vagy generált értékek.
  De egy szofisztikáltabb változatban figyelembe vehetjük a valós szövegek jellemzőit.
}
Vegyük most azt a virtuális listát, melyen keresztül ezek Descartes-szorzatát érjük el.
Nem kell mást tennünk, mint ezt a listát a kétfázisú értékkiosztással alkalmazni.
Ha jó nekünk, hogy minden érték $L$ szóból áll, készen is vagyunk.

Ha viszont változó szószámot szeretnénk,
akkor még gondoskodni kell a szövegek fennmaradó részének előállításáról.
Ehhez állítsunk elő egy-egy függvényt a szótár minden egyes szavára\footnote{
  Feltételezzük, hogy a szótár nem túl nagy (például lorem ipsum szavak).
  De nagy szótár esetén is van egy egyszerű kerülőmegoldás:
  a függvényt több szinten valósítjuk meg,
  először a szótár nagy szeleteit osztjuk ki,
  majd azon belül kisebb szeleteket, és így tovább, végül az egyes szavakat.
  Így a szó ellenőrzése az adott sorindexre még mindig logaritmikus számítási igényű.
}, mely lényegileg a két logikai érték rányújtása:
bármely sorindexre megadja, hogy az adott szó szerepel-e a hozzá tartozó szövegben,
illetve bármely szóra megadja a sorindexeket, ahol a szó szerepel.

Már csak annyi feladatunk van, hogy bármely sorindexre következetesen visszaadjunk egy olyan szöveget,
mely megfelel ennek a két kritériumnak:

\begin{enumerate}
  \item Az első $L$ szó egyezik az első szakaszban meghatározott prefixszel.
  \item A fennmaradó rész pontosan azokat a szavakat tartalmazza,
        amely a fennmaradó rész kiosztásánál leírt szóválasztásnak megfelel.
        Ugyanaz a szó többször is szerepelhet.
\end{enumerate}

A második kritérium természetesen legegyszerűbben úgy teljesíthető,
hogy a kiválasztott szavakat abc-rendben felsoroljuk.
De mivel teljes szabadságunk van (az index már biztosított),
tetszőlegesen szofisztikált módszereket alkalmazhatunk a minél életszerűbb szöveg kialakítására
(ez egy skálázható opció).

A rendezésnél kihasználjuk, hogy az első $L$ szóra már van egy hagyományos indexünk,
így a prefixek egymáshoz képesti rendezése már megoldott.
Mivel a Descartes-szorzat miatt a lehetséges prefixek listája igen nagy,
feltehetjük, hogy jellemzően nem nagyon lesznek ismétlődő prefixek,
de ha igen, csak azokon belül kell tényleges összehasonlításos rendezést végezni.

\subsection{Nem-indexelt egyoszlopos értékkiosztások}

A nem-indexelt oszlopok (melyek jellemzően terjedelmesebb adattartalmak)
szimulálásakor a keresési-rendezési szempontokat egyáltalán nem kell figyelembe venni.
Az indexelt oszlopokra vonatkozó elvárások közül így csak az első kettő releváns:

\begin{enumerate}
  \item hatékony elérés (random access)
  \item pozíciótól függő érték (seed + sorindex)
\end{enumerate}

Vagyis elég, ha a \texttt{TreeRandom} által a sorhoz generált seed alapján
előállítunk egy \texttt{Random} példányt.
Ennek felhasználásával a tartalmat tetszőleges determinisztikus módszerrel állíthatjuk elő.
Erre az előállításra kizárólag a konfigurációban megadott beállítások jelentenek megszorítást.

A következő listában csak fölvillantanám az ilyen adattartalmak néhány jellegzetes típusát:\footnote{
  Amelyeket érdemes beépítetten is támogatni, nyilván a lehetőségek korlátlanok.
}

\begin{itemize}
  \item \textbf{Egyszerű szöveg:}
    a legegyszerűbb megoldásban egy szótár szavait véletlenszerűen helyezzük egymás után,
    közben feljavítva a szövegképet nagybetűs szavakkal és központozással
    (az eredmény tovább javítható kifejezésminták használatával,
    amikor időnként egy többszavas részletre előre adott sablont használunk)
  \item \textbf{Strukturált szöveg:}
    először előállítunk egy általános struktúrát (címek, bekezdések stb.),
    majd ennek elemeit feltöltjük szöveggel,
    végül a struktúrát valamilyen jelölőnyelven szolgáltatjuk (HTML, MarkDown, plain text stb.)
  \item \textbf{Strukturált adat:}
    generált vagy konfigurációban megadott adat-schema alapján rekurzívan generáljuk le az adatstruktúrát,
    a schema-nyelv (pl. JSON Schema) és a kimenet formátuma is konfigurálható (JSON, YAML, TOML stb.)
  \item \textbf{Egyszerűbb képek:}
    véletlen színű háttérre véletlen paraméterekkel
    rárajzolunk néhány egyszerű alakzatot,
    majd a megadott vektoros/raszteres formátumban szolgáltatjuk
  \item \textbf{Jelszó-hash:}
    tulajdonképpen elég a hash értéket magára a seedre generálni
  \item \textbf{Általános BLOB/CLOB:}
    lekéréskor a konfigurációban megadott mérethatárok közötti bájtsort/karaktersort kell visszaadni,
    ami könnyen ellátható random bájtok/karakterek generálásával
\end{itemize}

\subsection{Értékkiosztás oszlopok közötti megkötésekkel}

\todo[inline]{subsubsection: Értékkiosztás oszlopok közötti megkötésekkel}

\subsection{Táblák közötti kapcsolatok}

\todo[inline]{subsubsection: Táblák közötti kapcsolatok (idegen értékkészlet; kiszervezett megkötések)}

\section{Az írhatósági réteg}

\todo[inline]{section: Az írhatósági réteg}

\section{Továbbfejlesztési tervek}

\todo[inline]{section: Továbbfejlesztési tervek}

\subsection{Megkötések oszlopok között}

\todo[inline]{subsection: Megkötések oszlopok között}

\chapter{Lekérdezések futtatása}

\section{A beépített SQL-futtató}

\todo[inline]{section: A beépített SQL-futtató}

\section{Használat az Apache Calcite keretrendszerrel}

\todo[inline]{section: Használat az Apache Calcite keretrendszerrel}

\section{Munkamenetek}

\todo[inline]{section: Munkamenetek}

\chapter{Kiegészítő eszközök és alkalmazások}

\section{Hálózati protokollok}

\todo[inline]{section: Hálózati protokollok}

\section{JDBC}

\todo[inline, color=red]{section: JDBC}

\section{REPL}

\todo[inline]{section: REPL}

\todo[inline]{További kiegészítő eszközök?}

\chapter{Összehasonlítás az elterjedt tipikus megoldásokkal}

\section{Megközelítések}

\todo[inline]{section: Megközelítések}

%Data Masking Solutions: Tools like Delphix or Varonis focus on data masking and de-identification for testing environments. They operate on existing data and anonymize it for secure testing.
%Data Generators: Tools like Redgate's SQL Data Generator, ApexSQL Generate, or dbForge Data Generator for MySQL create synthetic data based on the schema. They populate databases with fake but coherent data for testing.
%ORM-based Mocking: Libraries like Mockito for Java or Moq for C# allow mocking at the ORM layer rather than the database layer, providing a way to simulate database operations in memory.
%In-memory Databases: Databases like SQLite (in-memory mode), H2, or Redis can be used for fast, lightweight testing but require data to be populated for each test cycle.
%Service Virtualization: Tools like WireMock or Postman can be used to mock RESTful services that would typically interact with a database, thereby providing a way to simulate database behavior without a real database.
%Snapshot and Restore: Some databases offer quick snapshot and restore features that can be used to quickly reset a database to a known state for testing.
%Record-Replay Frameworks: Tools like rr for C/C++ offer a way to record system calls (including database interactions) and replay them, which can be used for debugging and testing.
%   FAKER?

\begin{table}[h!]
  \begin{center}
    \begin{tabular}{|c|c|c|}
      \textbf{Value 1} &
      \textbf{Value 2} &
      \textbf{Value 3} \\
      \hline
      1 & 1110.1 & a\\
      2 & 10.1 & b\\
      3 & 23.113231 & c\\
      4 & 25.113231 & d\\ % <-- added row here
    \end{tabular}
    \caption{A jelen megoldás összehasonlítása létező alternatívákkal}
  \end{center}
\end{table}

\section{A jelen megoldás sajátos fókuszai}

\todo[inline]{section: A jelen megoldás sajátos fókuszai}

\section{Empirikus tesztek}

\todo[inline]{section: Empirikus tesztek}

\begin{table}
\settowidth\rotheadsize{mmmmmmm}
\begin{tabularx}{\textwidth}{l| c *{8}{|Y} c}
  \toprule
  \parbox{2cm}{Fázis / \\ aspektus} &
    \rothead{MySQL \\ (fájlmásolással)} &
    \rothead{MySQL \\ (SQL dumppal)} &
    \rothead{MySQL + anon. \\ (fájlmásolással)} &
    \rothead{MySQL + anon. \\ (SQL dumppal)} &
    \rothead{MySQL + faker} &
    \rothead{H2 + faker \\ (embedded)} &
    \rothead{H2 Views \\ (embedded)} &
    \rothead{HoloDB \\ (default exec.)} &
    \rothead{HoloDB \\ (Calcite exec.)} 
    \\
  \midrule
  \parbox{2cm}{\rhpad Projekt \\ előfeltétele \rhpad} &
    \multicolumn{2}{c|}{ \begin{tabular}{@{}c@{}}létező \\ adatbázis\end{tabular} } & % MySQL
    \multicolumn{2}{c|}{ \begin{tabular}{@{}c@{}}kész \\ schema\end{tabular} } & % MySQL + anon.
    \multicolumn{5}{c|}{ \begin{tabular}{@{}c@{}}vázlatos \\ schema\end{tabular} } \\ % MySQL + anon.
  \parbox{2cm}{\rhpad Mockolás \\ előfeltétele \rhpad} &
    \multicolumn{2}{c|}{ \begin{tabular}{@{}c@{}}létező \\ adatbázis\end{tabular} } & % MySQL
    \multicolumn{2}{c|}{ \begin{tabular}{@{}c@{}}kész \\ schema\end{tabular} } & % MySQL + anon.
    \multicolumn{3}{c|}{ \begin{tabular}{@{}c@{}}vázlatos \\ schema\end{tabular} } & % MySQL + anon.
    \multicolumn{2}{c}{ \begin{tabular}{@{}c@{}}deklaratív \\ konfiguráció\end{tabular} } \\ % HoloDB
  \parbox{2cm}{\rhpad Data dump \\ (seconds) \rhpad} &
    0.05\guessvalue & % MySQL \\ (fájlmásolással)
    0.94\guessvalue & % MySQL \\ (SQL dumppal)
    0.32\guessvalue & % MySQL + anon. \\ (fájlmásolással)
    1.23\guessvalue & % MySQL + anon. \\ (SQL dumppal)
    0.12\guessvalue & % MySQL + faker
    0.11\guessvalue & % H2 + faker \\ (embedded)
    0 & % H2 Views \\ (embedded)
    0 & % HoloDB \\ (default exec.)
    0 \\ % HoloDB \\ (Calcite exec.)
  \parbox{2cm}{\rhpad Klónozás \\ tesztenként \\ (seconds) \rhpad} &
    \multicolumn{5}{c|}{ \begin{tabular}{@{}c@{}}0.05\guessvalue\end{tabular} } & % MySQL
    0.11\guessvalue & % H2 + faker \\ (embedded)
    0 & % H2 Views \\ (embedded)
    0 & % HoloDB \\ (default exec.)
    0 \\ % HoloDB \\ (Calcite exec.)
  \parbox{2cm}{\rhpad Alap \\ tesztszvit \\ (seconds) \rhpad} &
    \multicolumn{5}{c|}{ \begin{tabular}{@{}c@{}}0.02\guessvalue\end{tabular} } & % MySQL
    0.03\guessvalue & % H2 + faker \\ (embedded)
    0.68\guessvalue & % H2 Views \\ (embedded)
    0.11\guessvalue & % HoloDB \\ (default exec.)
    0.23\guessvalue \\ % HoloDB \\ (Calcite exec.)
  \parbox{2cm}{\rhpad Haladó \\ tesztszvit \\ (seconds) \rhpad} &
    \multicolumn{5}{c|}{ \begin{tabular}{@{}c@{}}1.72\guessvalue\end{tabular} } & % MySQL
    0.96\guessvalue & % H2 + faker \\ (embedded)
    12.7\guessvalue & % H2 Views \\ (embedded)
    3.1\guessvalue & % HoloDB \\ (default exec.)
    3.5\guessvalue \\ % HoloDB \\ (Calcite exec.)
  \parbox{2cm}{\rhpad Tear down \\ (seconds) \rhpad} &
    0.05\guessvalue & % MySQL \\ (fájlmásolással)
    0.94\guessvalue & % MySQL \\ (SQL dumppal)
    0.32\guessvalue & % MySQL + anon. \\ (fájlmásolással)
    1.23\guessvalue & % MySQL + anon. \\ (SQL dumppal)
    0.12\guessvalue & % MySQL + faker
    0.05\guessvalue & % H2 + faker \\ (embedded)
    0.05\guessvalue & % H2 Views \\ (embedded)
    0.01\guessvalue & % HoloDB \\ (default exec.)
    0.01\guessvalue \\ % HoloDB \\ (Calcite exec.)
  \parbox{2cm}{\rhpad Össztárhely \\ (bytes) \rhpad} &
    370M\guessvalue & % MySQL \\ (fájlmásolással)
    510M\guessvalue & % MySQL \\ (SQL dumppal)
    380M\guessvalue & % MySQL + anon. \\ (fájlmásolással)
    520M\guessvalue & % MySQL + anon. \\ (SQL dumppal)
    350M\guessvalue & % MySQL + faker
    360M\guessvalue & % H2 + faker \\ (embedded)
    1M\guessvalue & % H2 Views \\ (embedded)
    1M\guessvalue & % HoloDB \\ (default exec.)
    1M\guessvalue \\ % HoloDB \\ (Calcite exec.)
    
    
  \bottomrule
\end{tabularx}
\caption{Az \texttt{imdb\_ijs} dataset mockolásának performanciája a vizsgált megközelítésekkel, azonos tesztforgatókönyv mellett}
\label{tab:comp_table}
\end{table}


\chapter{Konklúzió}

\todo[inline]{section: Konklúzió}

\end{document}